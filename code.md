# Общие принципы написания кода

## 1. Переносим ответственность за корректность кода на компилятор

Ошибки в логике должны приводить к ошибкам компиляции, а не к runtime-ошибкам.

### 1.1. Строгое описание типов, классов и функций
- Используем систему типов для выражения всех ограничений и инвариантов
- Компилятор проверяет корректность кода на этапе компиляции
- Ограничения выражаются в типах, а не в документации или runtime-проверках

### 1.2. Невозможные состояния должны быть невыразимыми
- Если ограничение можно выразить в типах, мы должны это сделать
- Состояния, которые недопустимы по логике домена, должны быть невозможны на уровне типов

---

## 2. Код невозможно использовать некорректно

Структура кода сама предотвращает неправильное использование, без необходимости в "договорённостях" или документации.

### 2.1. Объекты валидны с момента создания
- Если компилятор позволяет создать объект, значит этот объект уже в корректном состоянии
- Нет двухфазной инициализации (создать, потом инициализировать)
- Используем smart-конструкторы для гарантии валидности

### 2.2. Функции обрабатывают все возможные варианты входных данных
- Функция написана исходя из ограничений входных аргументов, проверяемых компилятором
- Не пишем защитный код для ограничений, уже гарантированных типами
- Используем exhaustive pattern matching (компилятор требует обработки всех случаев)

---

## 3. Программные сущности не зависят от контекста использования

Реализация не должна знать, в каком месте или сценарии её будут использовать.

- Сущности проектируются в терминах домена, а не конкретного использования
- Нет предположений о "типичном" сценарии использования
- Код остаётся корректным независимо от контекста

---

## 4. Функциональный подход

Предпочитаем чистые преобразования мутациям состояния.

- Неизменяемые структуры данных
- Чистые функции без побочных эффектов
- Композиция функций вместо последовательности мутаций
- Изоляция мутаций в чётко определённых местах

---

## 5. Баланс между строгостью и читаемостью

Строгость не должна критично портить читаемость кода.

- По умолчанию выбираем строгое типобезопасное решение
- Ослабляем строгость только если она значительно ухудшает читаемость
- Это редкое исключение, а не правило
- Если ослабляем строгость, документируем причину

---

## 6. Явная обработка ошибок

Ошибки должны быть явными и содержать контекст.

- Лучше упасть громко и понятно, чем тихо делать что-то неправильное
- Ошибки содержат контекст (где произошло, что пошло не так)
- Валидация данных происходит на этапе парсинга/конвертации, а не позже
- Нет молчаливых деградаций (возврат null/пустого значения при невалидных данных)

---

# Практические принципы написания кода

Практическое применение общих принципов в конкретных техниках и паттернах.

## 1. Sealed типы для исчерпывающих вариантов

Применение принципа "невозможные состояния невыразимы" и "функции обрабатывают все возможные варианты".

### 1.1. Использование sealed classes и sealed interfaces
- Используем `sealed interface` или `sealed class` для всех дискриминационных объединений
- Все возможные варианты должны быть явно перечислены в sealed типе
- Не используем enum, когда варианты имеют разные структуры данных

### 1.2. Exhaustive when выражения
- Всегда используем exhaustive `when` выражения (компилятор требует обработки всех случаев)
- Компилятор не даст скомпилировать код, если забыли обработать какой-то вариант
- При добавлении нового варианта в sealed тип компилятор укажет все места, где нужно добавить обработку

### 1.3. Генерация sealed типов через @SealUp
- Используем `@SealUp` для генерации sealed типов там, где это уместно
- Это гарантирует синхронность между вариантами и их обработкой
- Уменьшает ручное дублирование кода

---

## 2. NonEmpty коллекции вместо обычных

Применение принципа "невозможные состояния невыразимы" для коллекций.

- Используем `NonEmptyList`, `NonEmptySet` вместо обычных коллекций там, где пустота невозможна по логике домена
- Не используем обычные `List`/`Set` там, где непустота гарантирована доменной логикой
- Тип сам гарантирует, что коллекция не пуста, не нужно проверять это в runtime

---

## 3. Кодогенерация для повторяющихся паттернов

Применение принципа "переносим ответственность на компилятор" через автоматизацию.

### 3.1. @SealUp для sealed типов
- Генерируем sealed типы через `@SealUp` для устранения ручного дублирования
- Гарантируем синхронность между вариантами и их обработкой

### 3.2. @Pipe для dependency injection
- Используем `@Pipe` для генерации кода dependency injection
- Структура зависимостей проверяется компилятором, а не в runtime

### 3.3. @EnumValues для enum
- Используем `@EnumValues` для генерации значений enum
- Гарантируем синхронность между определением enum и его использованием

---

## 4. Value classes для доменных типов

Применение принципа "строгое описание типов" для примитивов.

- Используем `@JvmInline value class` для всех доменных сущностей вместо сырых примитивов
- Создаём типы даже для простых вещей, если они имеют семантическое значение в домене
- Не используем `String`, `Int`, `Long` в публичных API там, где существуют доменные типы
- Компилятор не даст перепутать разные типы, даже если они основаны на одном примитиве

---

## 5. Smart-конструкторы для валидности объектов

Применение принципа "объекты валидны с момента создания".

- Используем private конструкторы + companion object factory methods
- Валидация происходит в factory-методе, объект создаётся только если он валиден
- Нельзя создать объект в невалидном состоянии через публичный API

---

## 6. Функциональная обработка null и опциональных значений

Применение принципа "функциональный подход" и "явная обработка ошибок".

- Используем `ifNull`, `foldNullable`, `foldBoolean` вместо проверок `!= null`
- Не пишем защитный код для null там, где тип уже гарантирует не-null
- Явно обрабатываем null там, где он возможен, не возвращаем null молча
- Используем `toNonEmptyListOrNull()`, `toNonEmptySetOrNull()` с явной обработкой ошибок

---

## 7. Предпочтение when над if-else

Применение принципа "функции обрабатывают все возможные варианты".

- Используем `when` для всех множественных ветвлений
- Предпочитаем `when` даже для простых if-else, если это улучшает читаемость
- Exhaustive `when` с sealed-типами предотвращает забытые случаи
- Компилятор требует обработки всех вариантов в exhaustive when

---

## 8. Неизменяемость структур данных

Применение принципа "функциональный подход".

- Используем `data class` для неизменяемых структур
- Предпочитаем `val` вместо `var`
- Изолируем мутации в чётко определённых местах (например, `MutableStateFlow` в `Skeleton` классах)
- Не используем скрытые мутации или глобальное изменяемое состояние

---

## 9. Операторы для доменных типов

Применение принципа "строгое описание типов" и улучшение читаемости.

- Перегружаем операторы для доменных типов (`Amount + Amount`, `-Amount`)
- Используем `operator fun plus()` для композиции конфигураций
- Операции остаются типобезопасными и явными
- Код становится более читаемым и естественным для домена

---

## 10. Companion objects для парсеров и утилит

Применение принципа "код невозможно использовать некорректно".

- Храним парсеры в `companion object` типов
- Создаём `Mapper`-ы для преобразований в companion objects
- Используем companion objects для констант и factory-методов
- Не создаём отдельные utility-функции, когда они логически принадлежат типу

---

## 11. Избегание исключений в пользу обобщённых типов

Применение принципа "функциональный подход" и "явная обработка ошибок".

- Используем `Either<Error, Success>` вместо исключений для операций, которые могут завершиться ошибкой
- Ошибки становятся частью типа возвращаемого значения, а не скрытыми побочными эффектами
- Компилятор требует явной обработки ошибок, нельзя забыть обработать ошибку
- Функции остаются чистыми (без побочных эффектов)
- Исключения допустимы только для действительно исключительных ситуаций (programming errors, системные ошибки)
- Не используем исключения для бизнес-логики или валидации данных
- Для ошибок, которые являются частью нормального потока выполнения, используем `Either`

---

## 12. Принцип «Parse, don't validate»

Применение принципа «Объекты валидны с момента создания».

- Мы не просто проверяем данные на корректность, мы преобразуем их из менее структурированного формата (например, String) в более структурированный доменный тип (Email, User).
- Если данные прошли через «парсинг», остальной код может быть уверен в их корректности без повторных проверок.
- Логика «проверки» сосредоточена исключительно в точке входа (smart-конструкторе или маппере).

---

## 13. Изоляция побочных эффектов (IO)

Применение принципа «Программные сущности не зависят от контекста».

- Функции бизнес-логики должны быть детерминированными (чистыми).
- Все внешние зависимости (время, генерация ID, БД, сеть) передаются как аргументы или зависимости.
- Вместо вызова Clock.System.now() внутри функции, мы передаем Instant. Это делает логику на 100% тестируемой без использования моков.

---

## 14. Инкапсуляция по умолчанию (Minimum Visibility)

Применение принципа «Код невозможно использовать некорректно».

- Все классы, функции и свойства по умолчанию помечаются как internal или private.
- Это ограничивает «поверхность атаки» при рефакторинге и предотвращает использование случайных деталей реализации.

---

## 15. Документирование «Почему», а не «Что»

Применение принципа «Баланс между строгостью и читаемостью».

- Код должен быть самодокументированным в плане того, что он делает (благодаря строгим типам и именованию).
- Комментарии используются только для объяснения бизнес-контекста или причин выбора конкретного архитектурного решения.
- Если алгоритм сложный — даём ссылку на задачу в трекере или документацию в Notion/Confluence.

---

## 16. Код как самоочевидная сущность (Self-Describing Logic)
Применение принципа «Баланс между строгостью и читаемостью».

- Комментарий как признак неудачи: Если возникает желание написать комментарий, объясняющий, что делает код — значит, код не смог выразить себя сам. Вместо комментария следует отрефакторить код: выделить функции, улучшить именование или усилить типы, пока смысл не станет прозрачным.
- Прозрачность: Идеальный код настолько детерминирован и прост, что его корректность должна быть очевидна при чтении. Если для уверенности в коде вам нужно «обложить его тестами как щитом», возможно, стоит упростить саму логику.